#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,		 color1,				 sensorvexiq_colorgrayscale)
#pragma config(Sensor, in2,		 color2,				 sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, in3,		 color3,				 sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, in4,		 color4,				 sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, in6,		 switch1,				 sensorVexIQ_Touch)
#pragma config(Sensor, dgtl1,	 dist1,					 sensorSONAR_mm)
#pragma config(Sensor, I2C_1,	 enc1,					 sensorQuadEncoderOnI2CPort,		, AutoAssign )
#pragma config(Sensor, I2C_2,	 enc2,					 sensorQuadEncoderOnI2CPort,		, AutoAssign )
#pragma config(Motor,	 port1,						leftmotor,		 tmotorVex393_HBridge, PIDControl, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,	 port2,						rightmotor,		 tmotorVex393_MC29, PIDControl, driveRight, encoderPort, I2C_2)
#pragma config(Motor,	 port6,						rearmotor,		 tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

//#define leftmotor port1
//#define rightmotor port2
//#define rearmotor port6
#define brushspeed 127
#define gotime 5000
#define tapecolor 600
#define gospeed 50

#define angletime 2000						 //90degree rotate time

const char upmotor[2]={port3,port4};
#define rotate1 port5

void go_front(int time);
void go_rear(int time);
void turn_right(int angle);
void turn_left(int angle);
void set_parrel();
void start_competition();
void ball_isbig();

task brush(){
  for(;;){
          motor[rotate1]=127;
         }
}
task main()
{
	while(sensorvalue(color1)<tapecolor&&sensorvalue(color3)<tapecolor){
	cleartimer(T1);
	turn_left(5000);
	}
	clearLCDLine(0);											// Clear line 1 (0) of the LCD
	clearLCDLine(1);											// Clear line 2 (1) of the LCD

	bLCDBacklight = true;									// Turn on LCD Backlight

	displayLCDPos(0,0);										// Set the cursor to line 0, position 0 (top line, far left)

	displaylcdstring(0,0,"90deg angletime:");
	displayNextLCDChar((char)T1);
  clearTimer(T1);

  start_competition();
  while(SensorValue(color1)<tapecolor||SensorValue(color2)<tapecolor){
	startTask(brush);
	go_front(500);
	ball_isbig();
  }
  if(SensorValue(color1)<tapecolor||SensorValue(color4)<tapecolor){
  go_rear(500);
  }
  turn_left(90);
  go_front(500);
  turn_right(90);
  while(SensorValue(color1)<tapecolor||SensorValue(color2)<tapecolor){
	startTask(brush);
	go_front(500);
	ball_isbig();
  }
  turn_left(90);
  go_front(250);
  while(SensorValue(color1)<tapecolor||SensorValue(color2)<tapecolor){
  go_front(800);
  //turn_left(5);
  //turn_right(5);
  }
  turn_left(90);
  while(SensorValue(color1)<tapecolor||SensorValue(color2)<tapecolor){
  go_front(800);
  }
  turn_right(90);
  go_front(500);
}
void go_front(int time){
clearTimer(T1);
resetMotorEncoder(leftMotor);
resetMotorEncoder(rightMotor);
while(time1[T1]<time){

	  motor[leftmotor]=gospeed;
		motor[rightmotor]=gospeed;
	}
	if(getMotorEncoder(rightMotor)<getMotorEncoder(leftMotor)){
	while(getMotorEncoder(rightMotor)<=getMotorEncoder(leftMotor))
	 {
	   motor[rightmotor]=25;
	 }
	}
	if(getMotorEncoder(rightMotor)>getMotorEncoder(leftMotor)){
	while(getMotorEncoder(rightMotor)>=getMotorEncoder(leftMotor))
	 {
	   motor[leftmotor]=25;
	 }
	}
	clearTimer(T1);
}

void go_rear(int time){
clearTimer(T1);
resetMotorEncoder(leftMotor);
resetMotorEncoder(rightMotor);
	while(time1[T1]<5000){
		motor[leftmotor]=-gospeed;
		motor[rightmotor]=-gospeed;
	}
	if(getMotorEncoder(rightMotor)<getMotorEncoder(leftMotor)){
	while(getMotorEncoder(rightMotor)<=getMotorEncoder(leftMotor))
	 {
	   motor[rightmotor]=25;
	 }
	}
	if(getMotorEncoder(rightMotor)>getMotorEncoder(leftMotor)){
	while(getMotorEncoder(rightMotor)>=getMotorEncoder(leftMotor))
	 {
	   motor[leftmotor]=25;
	 }
	}
	clearTimer(T1);
}

void turn_right(int angle){
	clearTimer(T2);
	clearTimer(T3);
	time1[T2]=angletime*angle/90;
	while(time1[T3]<time1[T2] ){
		motor[leftmotor]=gospeed;
		motor[rightmotor]=-gospeed;
		motor[rearmotor]=gospeed;
	}
	clearTimer(T2);
	clearTimer(T3);
}
void turn_left(int angle){
	clearTimer(T2);
	clearTimer(T3);
	time1[T2]=angletime*angle/90;
	while(time1[T3]<time1[T2]){
		motor[leftmotor]=-gospeed;
		motor[rightmotor]=gospeed;
		motor[rearmotor]=-gospeed;
	}
}
void set_parrel(){

	while(sensorvalue(color2)<tapecolor&&sensorvalue(color3)<tapecolor&&sensorvalue(color4)<tapecolor){
		if(sensorvalue(color3)>tapecolor&&sensorValue(color4)<tapecolor){turn_left(15);}
		else if(sensorValue(color3)<tapecolor&&sensorValue(color4)>tapecolor){turn_right(15)}
	}
}
void start_competition(){
	wait1Msec(2000);												// Robot waits for 2000 milliseconds before executing program

	while(SensorValue(switch1) == 0)		// Instructs robot to do nothing while the touch sensor isn't pressed
	{
	}

	wait1Msec(250);													// Wait just a bit before moving on (to help touch sensor remain consistant
		go_front(2000);

}
void ball_isbig(){
if(sensorvalue(dist1)<80){
	for(int a=0;a<2;a++)
		{
			motor[upmotor[a]]=127;
		}
		sleep(2000);
	}
}
